# day001

## 1. 数据库

### 1.1 查看索引信息

1. sp_helpindex是用来查看指定表的索引信息的存储过程。
2. sp_help用来查看对象的基本信息。
3. sp_helpdb用来查看数据库的信息。
4. sp_helptext用来查看存储过程或函数的源代码。

### 1.2 where和having

```sql
在STUDENT表中按class_type统计数据行数分组情况后，筛选出数据行数为大于10行的组

A
SELECT class_type，COUNT（*） FROM STUDENT GROUP BY class_type HAVING COUNT(*)>10

B
SELECT class_type，COUNT（*） FROM STUDENT GROUP BY class_type WHERE COUNT(*)=10

C
SELECT class_type，COUNT（*） FROM STUDENT HAVING COUNT(*)>10 GROUP BY class_type

D
SELECT class_type，COUNT（*） FROM STUDENT WHERE COUNT(*) >10 GROUP BY class_type
```

>   WHERE不能接聚合函数（MAX、MIN、COUNT、SUM、AVG等）;HAVING后可以接聚合函数； 
>
>   WHERE用在GROUP BY前，先过滤后分组； 
>
>   HAVING用在GROUP BY之后，先分组后过滤，且使用HAVING一定要用到GRUOP BY，但用到GROUP BY 不一定有HAVING。 
>
>   这题就是考察where和having的区别是使用吧

### 1.3 full join

Oracle数据库支持full join，mysql是不支持full join的，但仍然可以同过左外连接+ **union**+右外连接实现   

### 1.4 视图.

下列关于视图的相关概念描述不正确的是（B)

A:	视图可以解决检索数据时一个表中得不到一个实体所有信息的问题

B:	视图是一种数据库对象，是从数据库的表或其他视图中导出的基表

C:	若基表的数据发生变化，则变化也会自动反映到视图中

D:	数据库存储的是视图的定义，不存放视图对应的数据

> 1. 视图是一种虚拟的表，由一个查询语句定义，可以从一个或多个表导出数据，用于简化数据访问和提高数据安全性。
> 2. 视图只存储视图的定义，不存储数据，所以当基表的数据发生变化时，视图也会相应地发生变化。
> 3. 视图可以解决检索数据时一个表中得不到一个实体所有信息的问题，可以对基表进行多表连接、聚合、筛选等操作。
> 4. 视图的定义可以包括查询语句、列名、列的数据类型、列的长度、列的别名等信息。
> 5. 视图有许多应用场景，如数据的隐藏、数据的保护、数据的简化和数据的聚合等。

## 2 链表反转

给定一个单链表的头结点pHead(该头节点是有值的，比如在下图，它的val是1)，长度为n，反转该链表后，返回新链表的表头。

数据范围： 0≤$n$≤10000≤*n$n$≤1000

要求：空间复杂度 $O(1)$ ，时间复杂度 $O(n)$ 。

如当输入链表{1,2,3}时，

经反转后，原链表变为{3,2,1}，所以对应的输出为{3,2,1}。

### 2.1 迭代

链表反转问题可以使用迭代法来解决。迭代法的具体思路是，用两个指针 `prev` 和 `cur` 分别指向链表中的前一个节点和当前节点，然后不断地将当前节点的 `next` 指针指向 `prev`，并将两个指针向后移动，直到遍历完整个链表。

具体的实现步骤如下：

1. 如果链表为空或者只有一个节点，则直接返回头节点。
2. 定义两个指针 `prev` 和 `cur`，初始时分别指向 `nil` 和头节点。
3. 遍历整个链表，直到 cur->nil 为止，每次遍历时执行以下操作：
   1. 将当前节点的 `next` 指针指向 `prev`。
   2. 将 `prev` 指针向后移动，指向当前节点。
   3. 将 `cur` 指针向后移动，指向当前节点的下一个节点。
4. 遍历结束后，将 `prev` 指针指向的节点作为新的头节点返回。

```go
func reverseList(head *ListNode) *ListNode {
    var prev *ListNode
    curr := head
    for curr != nil {
        next := curr.Next
        curr.Next = prev
        prev = curr
        curr = next
    }
    return prev
}
```

```python
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param head ListNode类 
# @return ListNode类
#
class Solution:
    def ReverseList(self , head: ListNode) -> ListNode:
        pre=ListNode(None)
        cur=head
        while cur!=None:
            node1=cur.next
            cur.next=pre
            pre=cur
            cur=node1

        return pre
```

### 2.2 递归

递归解决链表反转问题的思路如下：

1. 首先递归到链表的末尾节点。
2. 对于末尾节点的下一个节点，将其指向当前节点，实现反转。
3. 返回当前节点，作为下一次递归中的“末尾节点”。
4. 最终返回反转后的链表的头结点。

```go
func ReverseList(head *ListNode) *ListNode {
    //递归基 如果头节点为空或者头节点的下一个节点为空，直接返回
     if head == nil || head.Next == nil {
        return head
    }
    //传入参数为head.Next，即当前节点的下一个节点，而返回的结果则是从当前节点的下一个节点开始反转后得到的链表的头结点。
    newHead := ReverseList(head.Next)
    // 它们的作用是将原链表中每个节点的指针方向反转
    head.Next.Next = head
    head.Next = nil
    return newHead
}
```

```python
class Solution:
    def ReverseList(self , head: ListNode) -> ListNode:
        if head==None or head.next==None:
            return head
        new_head =self.ReverseList(head.next)
        head.next.next=head
        head.next=None
        return new_head
```

这里需要注意的是，在递归的过程中需要不断地修改链表节点之间的指向关系，因此在返回当前节点时需要将其下一个节点的指针指向当前节点，即`head.Next.Next = head`。另外，最后需要将原始头结点的指针置为nil，以免出现环形链表。

