# day002

## 1. 反转链表

将一个节点数为 size 链表 m 位置到 n 位置之间的区间反转，要求时间复杂度 *O*(*n*)，空间复杂为*O*(1)。

### 1.1 递归

```go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func reverseBetween(head *ListNode, m int, n int) *ListNode {
    if m == 1 {
        return reverse(head, n)
    }
    head.Next = reverseBetween(head.Next, m - 1, n - 1)
    return head
}
func reverse(head *ListNode, n int) *ListNode {
    if n == 1 {
        return head
    }
    last := reverse(head.Next, n - 1)
    next := head.Next.Next
    head.Next.Next = head
    head.Next = next
    return last
}
```

```python
# class ListNode:


#     def __init__(self, x):
#         self.val = x
#         self.next = None
#
# 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
#
# 
# @param head ListNode类 
# @param m int整型 
# @param n int整型 
# @return ListNode类
#
class Solution:
    def reserve(self,head: ListNode,n:int)->ListNode:
        if n == 1:
            return head
        last=self.reserve(head.next,n-1)
        next_node=head.next.next
        head.next.next=head
        head.next=next_node
        return last
    def reverseBetween(self , head: ListNode, m: int, n: int) -> ListNode:
        # write code here
        if m == 1:
            return self.reserve(head,n)
        head.next=self.reverseBetween(head.next,m-1,n-1)
        return head
```

下面我来详细的分析一下该两个函数的递归过程：

**反转指定节点之后的n个点数据**

递归基：当n==1时，肯定不用反转了，这时直接返回当前节点

反转后续的节点，我们假设反转的过程为一个黑盒模型，只要调用了该函数，我们就一定能保证该节点之后的n-1个节点已经发展成功了，现在我们只需要将当前节点head和后面已经反转后的节点拼接在一起就可以了。

现在我们只需要将相邻的两个节点进行反转就行。

```go
 next_node=head.next.next
 head.next.next=head
 head.next=next_node
```

我们画一幅图来简要描述一下此过程:
		现在我们的目标为反转1后面四个节点（包括1）

![](D:\桌面\note\yufan的刷题日记\images\002_结果集.png)

![](D:\桌面\note\yufan的刷题日记\images\002_2.png)

随机反转完成了，那么接下来随机反转链表就很容易了：

```python
def reverseBetween(self , head: ListNode, m: int, n: int) -> ListNode:
        # write code here
        if m == 1:
            return self.reserve(head,n)
        head.next=self.reverseBetween(head.next,m-1,n-1)
        return head
```

递归基：m==1时，直接调用reserve函数返回即可

![](D:\桌面\note\yufan的刷题日记\images\002-2.png)

### 2. 迭代

```go
func reverseBetween(head *ListNode, m int, n int) *ListNode {
  dummyNode:=&ListNode{
    Val: -1,
  }
  dummyNode.Next=head
  pre:=dummyNode
  for i:=0;i<m-1;i++{
    pre=pre.Next
  }
  cur:=pre.Next
  curNext:=cur.Next
  for i:=0;i<n-m;i++{
    curNext=cur.Next
    cur.Next=curNext.Next
    curNext.Next=pre.Next
    pre.Next=curNext
  }
  return dummyNode.Next
}
```

```python
class Solution:
    def reverseBetween(self , head: ListNode, m: int, n: int) -> ListNode:
        #加个表头
        res = ListNode(-1)
        res.next = head
        #前序节点
        pre = res 
        #当前节点
        cur = head 
        #找到m
        for i in range(1,m): 
            pre = cur
            cur = cur.next
        #从m反转到n
        for i in range(m, n): 
            temp = cur.next
            cur.next = temp.next
            temp.next = pre.next
            pre.next = temp
        #返回去掉表头
        return res.next 
```

