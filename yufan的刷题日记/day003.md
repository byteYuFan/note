# day003

## 1. 给定一个数组，求如果排序之后，相邻两数的最大差值。要求时间复杂度`o(N)`，且不能用非基于比较的排序。



题目要求是给定一个数组，我们需要找到将该数组排序后，相邻两个数之间的最大差值。同时，我们需要满足以下要求：时间复杂度为O(N)，并且不能使用非基于比较的排序算法。

假设我们有一个包含20个数字的数组：`[34, 12, 58, 2, 78, 43, 91, 23, 15, 87, 10, 51, 94, 31, 66, 19, 8, 72, 37, 63]`。

1. 我们根据`(maxValue-minValue)/(len(nums)-1)`得到桶的容量,在本道题中为`(94-2)/(20-1)`=4,即每个桶的容量为`4`,
2. 计算桶的数量`(94-2)/4 + 1`个桶，我们需要准备`24`个桶，这是整个运算的核心，这样必能保证，相邻的元素必然不会超过桶的容量，即就是结果出现在两个桶中，而不会出现在一个桶里面，因此我们不用考虑桶内，只用考虑非空桶的最大值和最小值之间的关系即可。

```go
package main

import (
	"fmt"
	"math"
)

func maximumGap(nums []int) int {
	if len(nums) < 2 {
		return 0
	}

	// 找到数组中的最小值和最大值
	minVal := math.MaxInt32
	maxVal := math.MinInt32
	for _, num := range nums {
		if num < minVal {
			minVal = num
		}
		if num > maxVal {
			maxVal = num
		}
	}

	// 计算桶的容量
	bucketSize := int(math.Max(1, float64((maxVal-minVal)/(len(nums)-1))))
	fmt.Println("bucketSize = ",bucketSize)
	// 计算桶的数量
	bucketNum := (maxVal-minVal)/bucketSize + 1

	// 创建桶数组，并初始化桶的最小值和最大值
	buckets := make([]struct{ Min, Max int }, bucketNum)
	for i := range buckets {
		buckets[i].Min = math.MaxInt32
		buckets[i].Max = math.MinInt32
	}

	// 将数字放入桶中
	for _, num := range nums {
		index := (num - minVal) / bucketSize
		if num < buckets[index].Min {
			buckets[index].Min = num
		}
		if num > buckets[index].Max {
			buckets[index].Max = num
		}
	}
	fmt.Println(buckets)
	// 计算相邻非空桶之间的最大差值
	prevMax := minVal
	maxGap := 0
	for _, bucket := range buckets {
		if bucket.Min == math.MaxInt32 && bucket.Max == math.MinInt32 {
			// 空桶，跳过
			continue
		}
		maxGap = int(math.Max(float64(maxGap), float64(bucket.Min-prevMax)))
		prevMax = bucket.Max
	}

	return maxGap
}

func main() {
	nums := []int{34, 12, 58, 2, 78, 43, 91, 23, 15, 87, 10, 51, 94, 31, 66, 19, 8, 72, 37, 63}
	maxGap := maximumGap(nums)
	fmt.Println("Maximum gap:", maxGap)
}
```
```c
#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>

// bucket 定义桶的结构
typedef struct bucket {
    int Max;
    int Min;
} bucket;

int max(int a, int b) {
    return a > b ? a : b;
}


int max_num_gap(int *arr, int len) {
    if (len < 2) {
        return 0;
    }
    int min_val = INT32_MAX;
    int max_val = INT32_MIN;
    for (int i = 0; i < len; i++) {
        arr[i] > max_val ? max_val = arr[i] : max_val;
        arr[i] < min_val ? min_val = arr[i] : min_val;
    }
    int bucket_size = max(1, (int) (max_val - min_val) / (len - 1));
    int bucket_nums = (max_val - min_val) / bucket_size + 1;

    bucket *buckets = (bucket *) malloc(sizeof(bucket) * bucket_nums);
    if (buckets == NULL) {
        exit(0);
    }
    for (int i = 0; i < bucket_nums; i++) {
        buckets[i].Max = INT32_MIN;
        buckets[i].Min = INT32_MAX;
    }
    for (int i = 0; i < len; i++) {
        int index = (arr[i] - min_val) / bucket_size;
        arr[i] < buckets[index].Min ? buckets[index].Min = arr[i] : buckets[index].Min;
        arr[i] > buckets[index].Max ? buckets[index].Max = arr[i] : buckets[index].Max;
    }
    int prev_max = min_val;
    int max_gap = 0;
    for (int i = 0; i < bucket_nums; i++) {
        if (buckets[i].Max == INT32_MIN && buckets[i].Min == INT32_MAX) {
            continue;
        }
        max_gap = max(max_gap, buckets[i].Min - prev_max);
        prev_max = buckets[i].Max;
    }
    return max_gap;
}

int main() {
    int nums[] ={34, 12, 58, 2, 78, 43, 91, 23, 15, 87, 10, 51, 94, 31, 66, 19, 8, 72, 37, 63};
    printf("max_gap=%d\n", max_num_gap(nums, sizeof(nums) / sizeof(int)));
    return 0;

}
```



每个元素入桶情况如下所示：
```shell
num = 34,       index=8
num = 12,       index=2
num = 58,       index=14
num = 2,        index=0
num = 78,       index=19
num = 43,       index=10
num = 91,       index=22
num = 23,       index=5
num = 15,       index=3
num = 87,       index=21
num = 10,       index=2
num = 51,       index=12
num = 94,       index=23
num = 31,       index=7
num = 66,       index=16
num = 19,       index=4
num = 8,        index=1
num = 72,       index=17
num = 37,       index=8
num = 63,       index=15
```

每个桶的装载情况如下所示：
```shell
第1个桶:max=2 , min=2
第2个桶:max=8 , min=8
第3个桶:max=12 , min=10
第4个桶:max=15 , min=15
第5个桶:max=19 , min=19
第6个桶:max=23 , min=23
第7个桶:max=-2147483648 , min=2147483647
第8个桶:max=31 , min=31
第9个桶:max=37 , min=34
第10个桶:max=-2147483648 , min=2147483647
第11个桶:max=43 , min=43
第12个桶:max=-2147483648 , min=2147483647
第13个桶:max=51 , min=51
第14个桶:max=-2147483648 , min=2147483647
第15个桶:max=58 , min=58
第16个桶:max=63 , min=63
第17个桶:max=66 , min=66
第18个桶:max=72 , min=72
第19个桶:max=-2147483648 , min=2147483647
第20个桶:max=78 , min=78
第21个桶:max=-2147483648 , min=2147483647
第22个桶:max=87 , min=87
第23个桶:max=91 , min=91
第24个桶:max=94 , min=94

```



## 2. 给出`n`个数字`a_1,a_2 ……a_n`,问最多有多少不重叠的非空区间，使得每个区间内数字的`XOR`都等于0



