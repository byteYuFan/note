## 1.const

1. **常量变量：** 声明一个不可修改的常量变量。一旦被初始化，其值不能再被改变。

   ```c++
   const int myConstVar = 5;
   // myConstVar = 10;  // 错误，常量不能被修改
   ```

2. **常量指针：** 声明一个指向常量数据的指针，这意味着不能通过该指针来修改数据的值。

   ```c++
   int regularVar = 10;
   const int* ptrToConst = &regularVar;
   // *ptrToConst = 15;  // 错误，不能通过指针修改数据
   ```

3. **指针常量：** 声明一个常量指针，指针本身的值（指向的地址）不能被修改，但可以通过该指针修改数据的值。

   ```c++
   int var = 20;
   int* const constPtr = &var;
   *constPtr = 25;  // 可以修改 var 的值
   // constPtr = &anotherVar;  // 错误，不能修改指针的值
   ```

4. **常量引用：** 声明一个常量引用，通过该引用可以读取数据，但不能通过引用修改数据的值。

   ```c++
   int num = 30;
   const int& constRef = num;
   // constRef = 35;  // 错误，不能通过引用修改数据
   ```

5. **常量成员函数：** 在类中声明一个常量成员函数，该函数不能修改类的非静态成员变量。

   ```c++
   class MyClass {
   public:
       int nonConstVar;
   
       void NonConstFunc() {
           nonConstVar = 42;  // 可以修改成员变量
       }
   
       void ConstFunc() const {
           // nonConstVar = 42;  // 错误，不能修改成员变量
       }
   };
   ```

## 2.define

`#define` 是 C++ 预处理器指令之一，用于创建预处理宏，这些宏在编译代码之前被文本替换。它通常用于定义常量、简单的函数宏和条件编译。在代码编译之前，预处理器会对 `#define` 定义的标识符进行文本替换，将其替换为定义的值或代码。

以下是 `#define` 的用法和示例：

1. **定义常量：** 使用 `#define` 定义一个常量，将标识符替换为指定的值。

   ```c
   #define PI 3.14159
   double radius = 5.0;
   double circumference = 2 * PI * radius;  // 在编译时替换为 2 * 3.14159 * 5.0
   ```

2. **函数宏：** 使用 `#define` 定义一个简单的函数宏，可以将其用作简单的函数替代。

   ```c
   #define SQUARE(x) ((x) * (x))
   int result = SQUARE(4);  // 在编译时替换为 (4) * (4)
   ```

   这种方式的宏存在潜在的问题，例如参数可能会被计算多次，导致意外的行为。

3. **条件编译：** 使用 `#define` 控制编译时包含或排除代码的部分，通常与条件编译指令（如 `#ifdef`、`#ifndef`、`#endif`、`#else` 和 `#elif`）结合使用。

   ```c
   #define DEBUG_MODE
   // ...
   #ifdef DEBUG_MODE
       // 在调试模式下执行的代码
   #endif
   ```

| 特点         | `const` 关键字                 | `#define` 预处理指令         |
| ------------ | ------------------------------ | ---------------------------- |
| 类型安全性   | 有类型信息，编译器进行类型检查 | 没有类型信息，纯文本替换     |
| 作用域       | 有作用域，定义在块范围内有效   | 没有作用域限制，全局可见     |
| 调试和可读性 | 可读性高，使用标识符           | 不易阅读，直接的文本替换     |
| 副作用       | 具有类型，可用于类型检查和优化 | 简单的文本替换，无类型信息   |
| 命名空间     | 可以在命名空间中使用           | 无命名空间概念，全局可见     |
| 适用性       | 安全、现代 C++ 中常用          | 特定情况下有用，但需谨慎使用 |

## 3.static

1. **静态局部变量：** 静态局部变量是在函数内部声明的，并使用 `static` 修饰。这些变量在程序运行期间保持其值，但只在声明它们的函数内可见。静态局部变量在第一次使用前进行初始化，之后不会被重复初始化。这对于需要记住状态的情况非常有用。

   ```c++
   void myFunction() {
       static int count = 0; // 静态局部变量
       count++;
       // ...
   }
   ```

2. **静态全局变量：** 静态全局变量是在函数外部、文件内声明的，使用 `static` 修饰。它们的作用域被限制在声明它们的文件内部，不同文件中的同名变量不会相互干扰。这有助于避免全局变量的命名冲突问题。

   ```c++
   //File1.cpp
   static int globalVar = 5; // 静态全局变量
   ```

3. **静态函数：** 静态函数是在函数外部、文件内部声明的，使用 `static` 修饰。这些函数的作用域也被限制在声明它们的文件内部，从而防止在其他文件中访问。这有助于模块化代码，并避免函数名冲突。

   ```c
   // File1.cpp
   static void myStaticFunction() {
       // ...
   }
   ```

4. **静态类成员变量：** 在类中使用 `static` 修饰的成员变量属于整个类，而不是类的每个实例。这意味着所有类的实例共享同一个静态成员变量，它不依赖于类的特定实例。这在需要跨实例共享数据时非常有用。

   ```c++
   class MyClass {
   public:
       static int sharedValue; // 静态类成员变量
   };
   
   int MyClass::sharedValue = 0; // 静态成员变量的定义
   ```

5. **静态类成员函数：** 使用 `static` 修饰的类成员函数不依赖于类的实例，因此可以直接通过类名调用。这些函数不能访问非静态成员变量，因为它们没有实例上下文。静态成员函数常用于执行与类相关但不依赖于特定实例的操作。

   ```c++
   class MyClass {
   public:
       static void myStaticFunction() {
           // ...
       }
   };
   ```

## 4.this

在 C++ 中，`this` 是一个指向当前类对象的指针，它在类的成员函数内部使用。它允许在成员函数内部访问调用该函数的对象的地址。`this` 指针使得类的成员函数能够正确地操作类的成员变量和其他成员函数，即使有同名的局部变量存在也能够正确区分。

以下是关于 `this` 指针的详细解释和使用示例：

1. **指针的类型：** `this` 是一个指向当前对象的非常特殊的指针，类型为指向类类型的常量指针。这意味着你不能通过 `this` 指针修改对象本身，但可以通过它访问对象的成员。

2. **用法示例：** 在成员函数内部，可以使用 `this` 指针来访问调用该函数的对象的成员。

   ```c++
   class MyClass {
   public:
       int x;
   
       void printX() {
           cout << "x = " << x << endl;
       }
   
       void setX(int newX) {
           x = newX;
       }
   
       void printThisAddress() {
           cout << "Address of this: " << this << endl;
       }
   };
   ```

3. **解决同名变量冲突：** 在成员函数中，如果有与成员变量同名的局部变量，可以使用 `this` 指针来明确访问成员变量。

   ```c++
   Class {
   public:
       int x;
   
       void setX(int x) {
           // 使用 this 指针来访问成员变量 x
           this->x = x;
       }
   };
   ```

4. **返回对象自身：** 在类的成员函数中，可以使用 `this` 指针返回对象自身，从而支持链式调用。

   ```c++
   class MyClass {
   public:
       MyClass& setX(int newX) {
           x = newX;
           return *this; // 返回对象自身
       }
   };
   ```

5. **在构造函数和析构函数中的使用：** 在构造函数和析构函数中也可以使用 `this` 指针，但要小心其生命周期。

   ```c++
   class MyClass {
   public:
       MyClass(int value) {
           this->value = value;
       }
   
       ~MyClass() {
           // 在析构函数中使用 this 指针
       }
   
   private:
       int value;
   };
   ```

## 5. inline 内联函数

### 特征

* 相当于把内联函数里面的内容写在调用内联函数处；
* 相当于不用执行进入函数的步骤，直接执行函数体；
* 相当于宏，却比宏多了类型检查，真正具有函数特性；
* 编译器一般不内联包含循环、递归、switch 等复杂操作的内联函数；
* 在类声明中定义的函数，除了虚函数的其他函数都会自动隐式地当成内联函数。

### 使用

inline 使用

```cpp
// 声明1（加 inline，建议使用）
inline int functionName(int first, int second,...);

// 声明2（不加 inline）
int functionName(int first, int second,...);

// 定义
inline int functionName(int first, int second,...) {/****/};

// 类内定义，隐式内联
class A {
    int doA() { return 0; }         // 隐式内联
}

// 类外定义，需要显式内联
class A {
    int doA();
}
inline int A::doA() { return 0; }   // 需要显式内联
```

### 编译器对 inline 函数的处理步骤

1. 将 inline 函数体复制到 inline 函数调用点处； 
2. 为所用 inline 函数中的局部变量分配内存空间； 
3. 将 inline 函数的的输入参数和返回值映射到调用方法的局部变量空间中； 
4. 如果 inline 函数有多个返回点，将其转变为 inline 函数代码块末尾的分支（使用 GOTO）。

### 优缺点

优点

1. 内联函数同宏函数一样将在被调用处进行代码展开，省去了参数压栈、栈帧开辟与回收，结果返回等，从而提高程序运行速度。
2. 内联函数相比宏函数来说，在代码展开时，会做安全检查或自动类型转换（同普通函数），而宏定义则不会。 
3. 在类中声明同时定义的成员函数，自动转化为内联函数，因此内联函数可以访问类的成员变量，宏定义则不能。
4. 内联函数在运行时可调试，而宏定义不可以。

缺点

1. 代码膨胀。内联是以代码膨胀（复制）为代价，消除函数调用带来的开销。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少。另一方面，每一处内联函数的调用都要复制代码，将使程序的总代码量增大，消耗更多的内存空间。
2. inline 函数无法随着函数库升级而升级。inline函数的改变需要重新编译，不像 non-inline 可以直接链接。
3. 是否内联，程序员不可控。内联函数只是对编译器的建议，是否对函数内联，决定权在于编译器。

### 虚函数（virtual）可以是内联函数（inline）吗？

> [Are "inline virtual" member functions ever actually "inlined"?](http://www.cs.technion.ac.il/users/yechiel/c++-faq/inline-virtuals.html)

* 虚函数可以是内联函数，内联是可以修饰虚函数的，但是当虚函数表现多态性的时候不能内联。
* 内联是在编译期建议编译器内联，而虚函数的多态性在运行期，编译器无法知道运行期调用哪个代码，因此虚函数表现为多态性时（运行期）不可以内联。
* `inline virtual` 唯一可以内联的时候是：编译器知道所调用的对象是哪个类（如 `Base::who()`），这只有在编译器具有实际对象而不是对象的指针或引用时才会发生。

虚函数内联使用

```cpp
#include <iostream>  
using namespace std;
class Base
{
public:
	inline virtual void who()
	{
		cout << "I am Base\n";
	}
	virtual ~Base() {}
};
class Derived : public Base
{
public:
	inline void who()  // 不写inline时隐式内联
	{
		cout << "I am Derived\n";
	}
};

int main()
{
	// 此处的虚函数 who()，是通过类（Base）的具体对象（b）来调用的，编译期间就能确定了，所以它可以是内联的，但最终是否内联取决于编译器。 
	Base b;
	b.who();

	// 此处的虚函数是通过指针调用的，呈现多态性，需要在运行时期间才能确定，所以不能为内联。  
	Base *ptr = new Derived();
	ptr->who();

	// 因为Base有虚析构函数（virtual ~Base() {}），所以 delete 时，会先调用派生类（Derived）析构函数，再调用基类（Base）析构函数，防止内存泄漏。
	delete ptr;
	ptr = nullptr;

	system("pause");
	return 0;
} 
```

## 6.virtual

在面向对象编程中，C++ 提供了虚函数（Virtual Function）的概念，用于实现多态性。虚函数允许在派生类中重新定义基类中已经定义的函数，从而在运行时根据对象的实际类型调用正确的函数实现。虚函数是实现运行时多态性的关键机制之一。

以下是关于虚函数的详细介绍和使用示例：

1. **定义虚函数：** 在基类中将函数声明为虚函数，使用 `virtual` 关键字进行标记。虚函数可以在派生类中重新定义，以便根据派生类的实际类型调用适当的函数实现。

   ```c++
   class Shape {
   public:
       virtual void draw() {
           // 基类的虚函数
       }
   };
   ```

2. **虚函数的多态性：** 通过将函数声明为虚函数，可以在派生类中重新定义它，从而实现运行时多态性。当通过基类指针或引用调用虚函数时，将根据实际对象类型来调用适当的函数实现。

   ```c++
   Shape* shapePtr;
   Circle circle;
   shapePtr = &circle;
   shapePtr->draw(); // 调用派生类 Circle 的 draw 函数
   ```

3. **纯虚函数和抽象类：** 可以将虚函数声明为纯虚函数，通过在声明后加上 `= 0` 来实现。类中包含纯虚函数的类被称为抽象类，抽象类不能被实例化，而只能作为基类使用。

   ```
   cppCopy codeclass AbstractShape {
   public:
       virtual void draw() = 0; // 纯虚函数
   };
   ```

4. **虚析构函数：** 在使用继承时，当基类指针指向派生类对象并删除这个指针时，如果基类的析构函数不是虚函数，可能会导致派生类的析构函数不被调用。为了正确地销毁对象，应该将基类的析构函数声明为虚函数。

   ```c++
   class Base {
   public:
       virtual ~Base() {
           // 虚析构函数
       }
   };
   ```

5. **动态绑定和静态绑定：** 虚函数的调用是在运行时根据对象的实际类型进行的，称为动态绑定。非虚函数的调用是在编译时根据指针或引用的声明类型进行的，称为静态绑定。

通过使用虚函数，你可以在继承关系中实现多态性，以更灵活和通用的方式编写代码。虚函数机制是 C++ 中面向对象编程的重要特性之一。

## 7.volint

在 C++ 中，`volatile` 是一个关键字，用于修饰变量，表明该变量可能会被程序之外的因素修改。它告诉编译器不要对这个变量的访问进行优化，以确保程序在读取或写入这个变量时不会出现意外的行为。

以下是关于 `volatile` 关键字的详细介绍和使用示例：

1. **用法和含义：** `volatile` 关键字被用于修饰变量，它的主要作用是告诉编译器不要对该变量的访问进行优化，因为该变量可能会在程序之外的地方被修改。这可以防止编译器错误地进行优化，从而确保程序的正确性。

2. **示例：**

   ```c++
   volatile int sensorValue = 0; // 使用 volatile 修饰变量
   
   void readSensor() {
       while (true) {
           sensorValue = readValueFromHardware(); // 变量可能在硬件中被修改
       }
   }
   
   void printSensorValue() {
       while (true) {
           int value = sensorValue; // 使用 volatile 修饰的变量需要读取最新值
           cout << "Sensor Value: " << value << endl;
       }
   }
   ```

3. **主要应用场景：**

   - **硬件寄存器：** 当变量表示硬件寄存器的状态时，它可能会在程序外部被修改，这就是 `volatile` 的一个主要应用场景。
   - **中断处理：** 在中断处理函数中，变量可能被中断修改，因此使用 `volatile` 可以确保在主程序中读取正确的值。
   - **多线程环境：** 在多线程环境中，一个线程可能修改变量，而另一个线程可能在不久之后读取该变量。

4. **与优化相关的注意事项：**

   - `volatile` 不会影响内存的访问模式，也不能用来保证多线程的原子性操作。
   - `volatile` 主要用于避免编译器过度优化访问变量，而不是用于同步或线程安全性。

请注意，尽管 `volatile` 可以用于标记那些在程序之外可能会被修改的变量，但在一些情况下（例如多线程环境），更适合使用 C++11 引入的 `std::atomic` 类或其他同步机制来确保正确的并发操作。